Instructions:
	Remember certain key Computer Science concepts of keeping your code SOLID, DRY (don’t repeat yourself) as well as providing adequate comments/docstrings to anybody trying to understand your code. 

You have recently joined Bank XYZ as a front office junior quantitative analyst. Your tasks are as below
BackGround:
Part A: Option Pricing Platform with Merton Jump Diffusion 
You are a quantitative developer working on the trading desk of Bank XYZ. Your manager has tasked you to design a Python project that should incorporate the below business requirements 
1) Architecture & Interfaces (OOP, SOLID, patterns)
	Your modules must be able to price options across various asset classes (eg FX, Equities, Interest Rates, Commodities, Crypto Currencies). 

	Define a pricing interface using both ABC and typing.Protocol (structural typing). 
	Create an Abstract Base class and introduce at least 2 useful abstract methods. Feel free to introduce other methods as well.
	Using Protocol demonstrates duck typing compatibility without inheritance
	Provide one concrete implementation for Equity Jump Calls. 

	Define some suitable methods your projects must have. Your module must be able to handle requirements to i) price options and their ii) individual Greeks (Delta, Gamma, Vega, Theta, Rho). 
Option prices can be calculated via a variety of pricing ways and its variants. 
	Black Scholes
	Black-Scholes-Merton (with dividends) 
	Black’s model (for futures/options on forwards)
	Binomial method 
	 Cox-Ross-Rubinstein (CRR) model 
	  Jarrow-Rudd model (alternative up/down factors)
	Trinomial method 
	Standard Trinomial Tree (Boyle’s Trinomial)
	Adaptive Trinomial Trees
iv)Finite Difference Methods 
	Explicit Euler (Forward Time, Central Space)
	Implicit Euler (Backward Time, Central Space)
	Crank-Nicolson Scheme
	ADI (Alternating Direction Implicit)
	PSOR (Projected Successive Over-Relaxation)
	Higher-Order Schemes

v)Monte Carlo methods  
	Quasi-Monte Carlo
	Least Squares Monte Carlo (LSMC)
	Jump Diffusion Monte Carlo
	Stochastic Volatility Monte Carlo
It is NOT necessary to implement any of the pricing methods or the Greeks as the details will be left to the desk quants of each asset class. 
	At runtime, a user should be able to use 1 or more of the pricing ways and its variants described above to calculate the option price. For example a trader may wish to use both Quasi-Monte Carlo and Implicit Euler methods to price an option to see the difference.

You are free to choose your implementation but a hint could be class GreeksMixin: A mixin class to add Greek calculations (Delta, Gamma, Vega, Theta, Rho) to options. This will allow modular addition of Greeks functionality across different option types. Similiarly there are different ways of calculating Greeks

	Analytical Formulas
	Bump-and-Revalue
	Tree-Based Greeks
	Finite Difference on PDE Grid
	Implied Greeks

	Apply at least two GoF patterns. Suggested: 
	Strategy (select pricing approach at runtime: Black Scholes / Binomial / MC Jump). You may implement stub strategies and call out where desk quants fill details. Use functions-as-strategies to show first class functions. 
	Factory (create instrument instances from config/JSON), or Decorator (wrap pricing calls with timing/logging)
Demonstrate inheritance vs composition: e.g., JumpProcess composed inside MertonJumpModel, while EquityOption inherits a common BaseOption. Explain your choice in the memo
        e) Your class design should clearly reflect each of the  SOLID principles and explain in your code 
2) Core Domain Classes
a) Use  @dataclass for model parameters and market inputs to reduce memory footprint and auto generate comparison/hash where useful. Show why regular classes are preferred if constructor logic gets complex. 
b) Use properties (@property, setter, deleter) for controlled access/validation of inputs (e.g., positive stock price). 
c) Implement dunder methods for rich behavior (some examples below): 
	__repr__/__str__ for readable diagnostics;
	__call__ to price an instance directly;
	__len__ (e.g., number of time steps);
	consider __iter__ to stream path results. 
d)Implement Descriptors for strict type/value checking (e.g., non negative volatility, unsigned integers for counts). Either a simple descriptor or the typed/unsigned/sized variants shown in class
e) Your module should have methods that allow a use to extract the price & Greeks of any option a user wishes to price. A good use of @property is encouraged here. 
3) Jump Diffusion Simulation
A specific example he has asked you to model is that it is common to model jumps in equities and FX modelling space where the jumps are modelled using a Poisson process
dS_t=(r-r_(j ) ) S_t dt+S_t 〖dZ〗_t+ J_t S_t 〖dN〗_t           
St  Index level at date t
 r Constant riskless short rate
r_j=λ(e^(μ_j+〖0.5δ〗^2 )-1) Drift correction for jump to maintain risk neutrality
σ Constant volatility of S
Zt Standard Brownian motion – random numbers generated
Yt  Jump at date t with a Poission distribution
N t Poisson process with intensity

The Euler discretization of the equation is below:
S_t=S_(t-Δt) {e^((r-r_j- 0.5σ^2 )Δt+ σΔt Z_t^1 )+(e^(μ_j+〖δZ〗_t^2 )-1) y_t}        
	Implement the Euler discretization of Merton jump diffusion with Poisson jumps (use your sample parameters). 

	Provide a generator (yield) that streams simulated terminal prices lazily to save memory. 
Feel free to create some parameters or use below as a sample test. The option price is simply given as Call Price = max (Terminal stock price – Option Strike, 0). Feel free to use a variety of option strikes.
             S0 = 100 (Initial stock price)
            r = 0.05  σ = 0.2  λ = 0.75      μ = -0.6   Δt = 0.25   T = 1.0
	Use Matplotlib to plot the pathways of the stock prices
4) Trader, Orders, and Containers
a) Define a Trader (ID/Name/Desk) and place a buy order of 100 jump options (Adam Jones, Desk: JapanEQExotics). and an actual buy order of 100 At-The -Money jump options on Nikkei 225 with 3M maturity Log timestamp, runtime, price, and any errors. 
b) Implement a custom container (e.g., TradeBlotter) by inheriting from collections.abc.MutableSequence, providing required abstract methods, plus utilities like sum_notional, filter_by_strike, and unique_underlier
The TradeBlotter clearly should contains Adam Jones’s trades.
5) Observability, Validation & Error Handling
a) Log the users and his details (eg Adam Jones) /time stamp of calling your code to price the option. Log the time taken to price the option as well as the price of the option. Log any errors produced from the pricing as well. You can use simple text files to log your output to. Please use Python logging module for this.
b) Yor code should reflect efficient use of descriptors, decorators , setters,  getters, dunder methods, functions as first class citizens. Your code should reflect validation of user inputs and calculated option values (eg negative values, string inputs, sanity checks on model parameters). Please implement appropriate error handling in your code
c)The user can also retrieve default values, user can override default values in the code via setters/getters. 
Some recommendations are below
•  Decorators: 
	@time_it to record wall clock runtime;
	@log_call leveraging @wraps to preserve metadata when stacking. 
	
•  Input validation: 
	Properties + descriptors reject invalid values (e.g., negative vol, bad types). 
	Raise domain specific exceptions (e.g., NegativeValueException)
7) Type Hints & Static Analysis
	Full type annotations across public APIs; use Protocol for structural typing; run MyPy and include its output (at least one run with --strict or documented checks)
8) Resource & Data Management
	Implement a context manager for pricing sessions and/or reading/writing results (e.g., SQLite). Show both class based __enter__/__exit__ and the @contextmanager variant to contrast flexibility. 
	Data IO: read sample trades from one source (Excel/CSV/JSON/SQLite), and write outputs (price/Greeks/log refs) back to one target (e.g., SQLite or CSV). Limit to 10 sample trades (as per your brief
Part B — Testing, Quality & Extensibility (30 marks)
8) Unit Testing 
Unit tests for: parameter validation (descriptors/properties), pricing call behavior, generator exhaustion, logging side effects (use temporary file), and container utilities. Include at least one test of @classmethod / @staticmethod helpers for constructing instruments. 
9) Coding Standards
	Enforce DRY & SOLID; document design choices (inheritance vs composition).
	MyPy report attached; docstrings present; __repr__ helpful; error messages actionable
10) Demonstrate use of your Python module
Your code should present an interface to the user to change the number of simulations, jump parameters or any other appropriate parameter.  Your code should also be able to read in different data sources like (SQLite database, Excel , CSV, JSON) and the output data down (ie option price) into a data source of your choice ( SQLite database, Excel , CSV, JSON)
Please only illustrate one example eg Excel with a sample of 10 trades with your own sample data Use efficient data structures like lists/dictionaries to make your code more robust and error-prone when handling the intermediate calculation process.
11) Self-Reflection
Prepare a simple document (maximum 2 pages) addressed to your non-technical manager explaining how you implemented the project, challenges you faced, what you could have improved on if you had more Python knowledge/resources.





Marking Rubric (100 marks total)
•  Architecture & Patterns (20) – ABC/Protocol, Strategy + another GoF (Factory/Decorator), SOLID/DRY reasoning. 
•  OOP Features (20) – properties, mixins, dunder methods, descriptors, inheritance vs composition; custom container via collections.abc. 
•  Jump Simulation & Pricing (15) – correct Euler with Poisson jumps; generator usage; multiple strikes; clean interface. 
•  Type Safety & Static Analysis (10) – complete type hints; Protocol; MyPy output included. 
•  Logging, Decorators, Context Managers (15) – structured logs, timing, stacked decorators with @wraps, DB/file CM usage. 
•  Data IO & Trader Workflow (10) – one end to end IO (read 10 trades, price, write results), blotter operations, order logging. 
•  Tests & Documentation (10) – pytest suite, design memo (see below), readable repr/str, exception messages